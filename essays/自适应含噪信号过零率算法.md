
[<font size=4>←返回主目录<font>](../README.md)</br>

<div align="right"><a href="../index.html" target="_self" title="返回主页"><img src="../images/Home.png"></a> <a href="#bottom" target="_self" title="跳转底部"><img src="../images/bottom.png"></a></div>

__文题__：自适应含噪信号过零率算法</br>

__作者__：xiahouzuoxin</br>

__日期__：2014-09-11</br>

-----------------------------------


本文讨论的是实际使用过程中计算过零率的一种自适应方法。过零率常用于语音检测识别中，一般叫短时过零率更贴切些（指一段短时平稳信号才能计算过零率），简单有效，近期亦打算将这个简单的概念用于识别脚步声和卡车声（近似短时平稳）。过零率的定义计算一般通过下面的表达式描述：

<img src="http://www.forkosh.com/mathtex.cgi? \Large Z_n=\frac{1}{2}\sum_{m=0}^{N-1}\|{sgn[x_n(m+1)]-sgn[x_n(m)]}\|">

过零率是对频率从时域进行的一种简单的度量，一般情况下，过零率越大频率近似越高，反正亦然，相关推倒可参考相关文献。

自然信号由于电路、环境引入的噪声会在0水平位置波动，直接按上式计算过零率，严重影响识别效果。因此，本文在计算过零率时，对信号的幅值进行阈值限定，阈值的计算方法是：

> 因为信号处理肯定是加窗一段一段的，所以使用上一次及本次采集的短时信号峰峰值Vpp的均值，再乘以对应的系数因子F（根据实际噪声环境确定，本文定义在0.1与0.2之间），作为本段信号计算过零率的限定阈值。

用数学形式表述更直观：

<img src="http://www.forkosh.com/mathtex.cgi? \Large THR=F*\frac{1}{2}\{V_{pp}(t)+V_{pp}(t-1)\}, F=[0.1\ 0.2]">

因此增加阈值判别后计算过零率的流程图为：

<center>![过零率流程图]</center>

对应的C程序为：

```c

/* signal thresh adaptive structure */
struct st_zerorate_thr{
    uint32_t pre;
    uint32_t cur;
};

/*
 * @brief   
 *   Calculate short time zero cross rate. Short time means n, n often choose to
 *   be a frame(256,512 and so on)
 *
 *   The diffrence with upstairs is that this one consider the adaptive thresh 
 *   when checking the signal, which removes the influence of noise.
 * @inputs  
 *   x[] - input sound signal
 *   n   - size of a frame
 * @outputs 
 * @retval  
 *   zero cross rate in a frame length
 */
uint16_t zero_rate(int16_t x[], int n, struct st_zerorate_thr thr)
{
    int      i        = 1;   /* Init to 1 */
    uint16_t zero_cnt = 0;
    float    tmp      = 0;
    uint8_t  x_pre    = 0;

    while ( (x[i] < thr.cur) && (x[i] > -thr.cur) && (i<n) ) {
        i++;
    }
    x_pre = x[i++];
    while ((i < n) && ((x[i] > thr.cur) || (x[i] < -thr.cur)) ) {
        tmp   = x[i] * x_pre;
        if (tmp < 0) {
            zero_cnt = zero_cnt + 1;
        }
        x_pre = x[i];
        i++;
    }

	return zero_cnt;
}
```

上面代码定义了阈值结构体`st_zerorate_thr`，更新阈值的方法按(2)式执行，

```
#define TH_FACTOR        (0.2f)   /* 0.1~0.2 */

void zerorate_thr_update(struct st_zerorate_thr thr, uint32_t peak_value)
{ 
    thr.pre = thr.cur;
    thr.cur = (uint32_t)(TH_FACTOR * ((thr.pre + peak_value)>>1) );
}
```


[过零率流程图]:../images/自适应含噪信号过零率算法/过零率流程图.png




<div align="right"><a href="../index.html" target="_self" title="返回主页"><img src="../images/Home.png"></a> <a href="#top" target="_self" title="返回顶部"><img src="../images/top.png"></a></div>
<a name="bottom"></a>
[<font size=4>←返回主目录<font>](../README.md)</br>

<!-- 

本模板为转成Html后需要修改的地方:
1. 修改README.md为README.html，共2处
2. 修改Github样式目录
3. 添加一键分享功能，源码在stylesheets目录下mystyle.md
4. 添加评论功能，并修改评论中的标题项等，源码在stylesheets目录下mystyle.md
5. 修正其它可能不正确的链接 

-->



