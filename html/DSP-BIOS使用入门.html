<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../stylesheets/Github.css" type="text/css" />
  <title>DSP-BIOS使用入门</title>
</head>
<body>
<div id="header"><center>
    <p class="header_titleline">
    <a href="../index.html" target="_self" title="主页">主页  </a><a href="../Search.html" target="_self" title="站内搜索">站内搜索  </a><a href="../Projects.html" target="_self" title="项目研究">项目研究  </a><a href="../Archives.html" target="_self" title="文章存档">文章存档  </a><a href="../README.html" target="_self" title="分类目录">分类目录 </a><a href="../AboutMe.html" target="_self" title="关于我">关于我  </a>
    </p>
</center></div>
<h1>DSP-BIOS使用入门</h1>
<h4>old / xiahouzuoxin</h4>
<h4>Tags: DSP</h4>
转载请注明出处: <a href="http://xiahouzuoxin.github.io/notes/">http://xiahouzuoxin.github.io/notes/</a>
<div id="TOC">
<ul>
<li><a href="#从环境说到搭建第一个工程">从环境说到搭建第一个工程</a></li>
<li><a href="#dspbios的配置方法">DSP/BIOS的配置方法</a></li>
<li><a href="#dspbios工程的启动顺序">DSP/BIOS工程的启动顺序</a></li>
<li><a href="#dspbios在dsp项目中的地位">DSP/BIOS在DSP项目中的地位</a></li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
</div>
<!---title:DSP-BIOS使用入门-->
<!---keywords:DSP-->
<!---date:old-->
<h2 id="从环境说到搭建第一个工程">从环境说到搭建第一个工程</h2>
<p>请注意，此文默认读者已经对DSP及CCS V3.3环境有一定的了解了，知道cmd文件的配置，知道新建工程，编译并连接仿真器下载！如果你对这些还都不熟悉，请先熟悉这些！当然，最好要有操作系统的基本概念——任务、调度、中断！</p>
<ol style="list-style-type: decimal">
<li><p>第一个问题：DSP/BIOS（好吧，我们一般这样写）是什么？</p>
<p>是TI公司专门为DSP开发的嵌入式实时操作系统，既然是TI公司为自己的DSP开发的——官方的，当然性能是杠杠的了（当然，我还在入门，这点也是道听途说，没有实际体会）。既然说到实时操作系统，那还有哪些嵌入式实时操作系统呢？Linux是吗——不是，VxWorks——是，哦，还有一个小的开源系统——uCOS II也是。</p></li>
<li><p>问题二：要使用DSP/BIOS，需要安装什么环境呢？</p>
<p>本文为CCS v3.3，默认就安装上DSP/BIOS，版本为V5.31.2（可以通过<code>Help-&gt;About...</code>菜单查看版本）。当然，如果需要其它版本（可以同时安装多个版本），可以到TI官网下载，链接：</p>
<p><a href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/bios/dspbios/index.html" class="uri">http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/bios/dspbios/index.html</a></p>
<p>请注意：DSP处理器型号、CCS版本、DSP/BIOS版本之间存在兼容性，请注意选择！</p>
<p>下载后安装到CCS所在目录，通过<code>Help-&gt;About...</code>中的Manager选择使用的BIOS版本！</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/1.png" alt="1" /><p class="caption">1</p>
</div>
<p>本文使用的是CCS V3.3默认的DSP/BIOS版本，即V5.31.2。无特殊说明，本文的例子运行在TI的CCS 3.3软件仿真模式下，仿真环境配置如下（使用C6713处理器仿真）：</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/2.png" alt="2" /><p class="caption">2</p>
</div></li>
<li><p>问题三：如何建立第一个BIOS工程？</p>
<p>先建立一个普通工程，<code>Project-&gt;New...</code>，如下：</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/3.png" alt="3" /><p class="caption">3</p>
</div>
<p><code>File-&gt;New-&gt;DSP/BIOS Configuration...</code>新建DSP/BIOS配置文件，</p>
<p><img src="../images/DSP-BIOS使用入门/4.png" alt="4" /> <img src="../images/DSP-BIOS使用入门/5.png" alt="5" /></p>
<p>保存一下，配置文件的后缀为*.tcf.</p>
<p>将__配置文件和由配置文件自动生成的cmd文件__添加到工程，</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/6.png" alt="6" /><p class="caption">6</p>
</div>
<p>新建一个main.c文件，<strong>把main.c添加到工程</strong>（总是忘记这个然后还到处找问题），写个最简单的代码吧，</p>
<pre><code>int main(void)
{
    return 0;
}
</code></pre>
<p>编译一下工程，此时出现错误提示：</p>
<pre><code>js: &quot;./bios_first.tcf&quot;, line 11: Heaps are enabled, but the segment for DSP/BIOS Objects (MEM.BIOSOBJSEG) is not set correctly. Please create a heap in one of your data segments and set MEM.BIOSOBJSEG to it.</code></pre>
<p>没关系，在下一小节将看到怎么去掉该错误！</p></li>
</ol>
<h2 id="dspbios的配置方法">DSP/BIOS的配置方法</h2>
<ol style="list-style-type: decimal">
<li><p>系统配置</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/7.png" alt="7" /><p class="caption">7</p>
</div>
<p>在Global Setting上右键属性，设置DSP目标板时钟，CLKOUT时钟以及大小端模式。</p>
<p>关于Call User Init Function选项，默认是打开的，如果连接有实体目标板，则最好在此处设置用户初始化PLL及EMIF等的代码的函数（有关PLL初始化话的代码参考其它C6713的工程）。否则软件仿真模式下，则去掉该选项能在运行时避免不少错误。</p>
<p>接下来配置SDRAM及堆大小，</p>
<p><img src="../images/DSP-BIOS使用入门/8.png" alt="8" /> <img src="../images/DSP-BIOS使用入门/9.png" alt="9" /></p>
<p>现在可以重新编译一下工程了，恭喜恭喜，编译成功！之前提示的堆错误就在这里解决的！</p>
<p>现在，就需要根据需求对SDRAM的存储空间进行划分（就是以前没使用操作系统时要写cmd文件一样，这里的划分将自动生成或修改cmd文件）。使用DSP/BIOS很方便，在MEM上右键<code>Insert MEM</code>就可插入分区了！这部分功能对应到cmd上就是类似于cmd中MEMORY的功能，</p>
<pre><code>MEMORY
{
    BOOT_RAM: o=00000000h,l=00000400h   
    IRAM    : o=00000400h,l=0003FC00h

    /* CE2: SDRM 256Mbit */
    SDRAM:  o = 80000000h,l=01000000h  /* 128Mbit */
    GB_MEM: o = 81000000h,l=01000000h  /* 128Mbit */ 

    /* Flash */
    FLASH_BOOT : o=90000000h,l=00000400h
    FLASH_REST : o=90000400h,l=000FFB00h 
}</code></pre></li>
<li><p>LOG的配置</p>
<p>LOG功能说白了就是用来实现printf的，STS用来捕获任意对象的计数值。</p>
<p>在LOG上右键<code>Insert LOG</code>，插入一个trace的打印对象，</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/10.png" alt="10" /><p class="caption">10</p>
</div>
<p>在main.c中编写如下代码，</p>
<pre><code>#include &quot;bios_firstcfg.h&quot; // DSP/BIOS自动生成，可以在工程下找到，包含了对trace的声明以及相关头文件的包含

int main(void)
{
    LOG_enable(&amp;trace);
    LOG_printf(&amp;trace, &quot;Hello DSP/BIOS %d.&quot;, 0); 

    return 0;
} </code></pre>
<p>编译通过后装载程序，打开菜单<code>DSP/BIOS-&gt;Message Log</code>，运行程序效果如图，</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/11.png" alt="11" /><p class="caption">11</p>
</div>
<p>注意，上面的程序中是通过LOG_printf函数而非printf打印消息的，其它的有关LOG的函数还有，</p>
<pre><code>LOG_disable. Disable the system log.
LOG_enable. Enable the system log.
LOG_error. Write a user error event to the system log.
LOG_event. Append unformatted message to message log.
LOG_event5. Append 5-argument unformatted message to log.
LOG_message. Write a user message event to the system log.
LOG_printf. Append formatted message to message log.
LOG_printf4. Append 4-argument formatted message to log.
LOG_reset. Reset the system log.</code></pre>
<p>好了，这是我们学习DSP/BIOS遇到的第1个模块（Module）——LOG模块。</p>
<p>其实DSP/BIOS中还有很多模块，参考TI文档《SPRU430S：TMS320C6000 DSP/BIOS 5.x Application Programming Interface (API) Reference Guide》</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/12.png" alt="12" /><p class="caption">12</p>
</div></li>
<li><p>任务模块的配置</p>
<p>操作系统最基本的就是任务，我们先来看看任务！新建两个任务，右键属性设置任务函数名，如图，</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/13.png" alt="13" /><p class="caption">13</p>
</div>
<p>对TSK_task1做相同的配置，请注意，其中的Task function要在C函数前加下划线！</p>
<p>在main函数中添加两个任务的代码，</p>
<pre><code>void func_task0(void)  // 对应刚才的_func_task0
{
    static Uint16 TSK0 = 0;

    while (1) {   // 任务一般都有死循环，只执行一次的任务意义不大
        LOG_printf(&amp;trace, &quot;TSK0=%u&quot;, TSK0++);
        TSK_yield();
    }       
}

void func_task1(void)  // 对应刚才的_func_task1
{
    static Uint16 TSK1 = 0;

    while (1) {
        LOG_printf(&amp;trace, &quot;TSK1=%u&quot;, TSK1++);
        TSK_yield();
    }       
}</code></pre>
<p>重新编译装载，运行后在Message Log窗口下看到的效果如下：</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/14.png" alt="14" /><p class="caption">14</p>
</div>
<p>操作系统的任务都是死循环的结构，要实现任务调度必须要让每个任务有空闲的时间，不妨把上面代码中的TSK_yield()注释掉，重新编译装载运行，此时程序会一直在func_task0中执行。</p>
<p>TSK_yield在这里的作用就是如果有相同优先级的任务，则调度到同优先级的其它任务执行！</p>
<p>TSK模块的属性有很多，除了设置函数名外，还可以设置优先级、输入参数等！调度函数也有很多，另一个常用的是使用睡眠调度函数——TSK_sleep，其使用如下：</p>
<pre><code>void func_task(void)
{
    while(1) {
        // 处理代码

        TSK_sleep(100);  // 100表示系统时钟计数
    }
}</code></pre></li>
<li><p>软中断SWI模块的配置</p>
<p>中断具有比任何任务都高的优先级，而其中硬件中断（HWI）又比软件中断（SWI）优先级更高。</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/15.png" alt="15" /><p class="caption">15</p>
</div>
<p>软中断邮箱不是信号中的消息邮箱，但机制类似，上面的值为软中断邮箱的复位值！</p>
<p>一旦软中断邮箱的值达到0时，触发软件中断，触发后一次执行完成（除非被硬件中断打断），执行完后软中断邮箱恢复到复位值！由于是一次执行完成，因此与任务不同，软中断中绝不会有死循环（否则就一直执行软中断，任务就别执行了）！</p>
<p>接下来完成软中断函数中的内容：task1每执行2次，触发一次软中断，软中断计数值+1。</p>
<pre><code>void func_task1(void)  // 对应刚才的_func_task1
{
    static Uint16 TSK1 = 0;

    while (1) {
        LOG_printf(&amp;trace, &quot;TSK1=%u&quot;, TSK1++);
        SWI_dec(&amp;ADC_swi);  // 软中断邮箱计数值递减
        TSK_yield();
    }       
}

void swi_adc(void)
{
    static Uint16 adc_cnt = 0;

    LOG_printf(&amp;trace, &quot;SWI_ADC=%u&quot;, adc_cnt++);

    // 一次执行完后，邮箱值恢复为初始值2
}</code></pre>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/16.png" alt="16" /><p class="caption">16</p>
</div>
<p>SWI_dec()函数用于修改软中断邮箱的计数值，其它对软中断邮箱操作的函数还包括：</p>
<pre><code>void SWI_or(swi, mask);  // 邮箱值与mask进行或操作，当值为0时触发软中断
SWI_Handle swi; /* SWI object handle*/
Uns mask; /* value to be ORed */

void SWI_andn(swi, mask);  // 邮箱值与mask进行与非操作，当值为0时触发软中断
SWI_Handle swi; /* SWI object handle*/
Uns mask /* inverse value to be ANDed */

void SWI_inc(swi);  // Increment SWI’s mailbox value and post the SWI
SWI_Handle swi; /* SWI object handle*/

void SWI_dec(swi);  // Decrement SWI’s mailbox value and post if mailbox becomes 0
SWI_Handle swi; /* SWI object handle*/</code></pre>
<p>6000系列的DSP软中断邮箱为32位，2000系列为16位。下面是从刘鑫茂的DSP/BIOS讲座PPT中截取的软中断邮箱函数的对比图及操作时邮箱值的变化过程图：</p>
<p><img src="../images/DSP-BIOS使用入门/17.png" alt="17" /> <img src="../images/DSP-BIOS使用入门/18.png" alt="18" /></p></li>
<li><p>信号量SEM模块的配置</p>
<p>信号量分互斥信号量和计数信号量，互斥信号量只有两种状态：可用于不可用，计数信号量通过设置一个计数值，如果计数值大于0，则任务请求该信号量时不被阻塞。</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/19.png" alt="19" /><p class="caption">19</p>
</div>
<p>编写程序：现在是任务执行2次进一次软中断，这里将信号量初始值设为1，task0中使用SEM_pend等待信号量，task0执行1次就进入等待状态，再过一次，进入软中断，软中断中使用SEM_post发布信号量，信号量值增1，task0收到信号量后从等待状态返回，继续执行！</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/20.png" alt="20" /><p class="caption">20</p>
</div>
<pre><code>status = SEM_pend(sem, timeout);
SEM_Handle sem; /* semaphore object handle */
Uns timeout; /* return after this many system clock ticks */

返回值：Bool status; /* TRUE if successful, FALSE if timeout */</code></pre>
<p>如果timeout=0表示不等待继续执行，SYS_FOREVER表示一直等待直到信号量的值大于0。SEM_post()函数相对简单，不赘述。</p></li>
<li><p>输入输出——实时数据交换模块配置</p>
<p>不知注意到没有，软件仿真模式下，使用Load装载程序时总会弹出如下的警告框，</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/22.png" alt="22" /><p class="caption">22</p>
</div>
<p>这就是RTDX模块没有配置的问题，在输入输出的RTDX模块上右键属性，配置如下，</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/23.png" alt="23" /><p class="caption">23</p>
</div>
<p>配置好后，重新编译，Load时就不会再弹出那警告框了！</p></li>
</ol>
<p>总结一下：其实，就让上文看到的一样，DSP/BIOS的模块还有很多，上面只是挑了几个比较常用的说了说，就光信号同步那一大块就还有消息邮箱、消息队列等，所谓举一反三，这些模块的功能及函数定义，或者想了解更多关于DSP/BIOS知识，都可以从下面的手册上找到：</p>
<ol style="list-style-type: decimal">
<li>SPRU430S: TMS320C6000 DSP/BIOS 5.x Application Programming Interface (API) Reference Guide</li>
<li>SPRU423F: TMS320 DSP BIOS User Guide</li>
<li>SPRU616A: DSP-BIOS Driver Developer's Guide</li>
</ol>
<p>除此之外，要想灵活的使用DSP/BIOS，毕竟它是一个操作系统，熟悉操作系统的基本概念很重要，如果学习或使用过uCOS ii或Linux这些去学习DSP/BIOS就小菜一碟了！</p>
<h2 id="dspbios工程的启动顺序">DSP/BIOS工程的启动顺序</h2>
<ol style="list-style-type: decimal">
<li><p>初始化DSP：DSP/BIOS程序从C/C++环境入口c_int00开始运行。对于C6000平台，在c_int00开始处，系统栈指针（B15）和全局页指针（B14）被分别设置在堆栈断的末尾和.bss断的开始。控制寄存器AMR、IER、CSR等被初始化；</p></li>
<li><p>初始化.bss段：当堆栈被设置完成后，初始化任务被调用，利用.cinit的记录对.bss断的变量进行初始化；</p></li>
<li><p>调用BIOS_init初始化用到的各个模块：BIOS_init调用MOD_init对配置用到的各个模块进行初始化，包括HWI_init、HST_init、IDL_init等；</p></li>
<li><p>处理.pinit表：.pinit表包含一些指向初始化函数的指针，对C++程序，全局对象类的创建也在此时完成；</p></li>
<li><p>调用用户程序的main函数：用户main函数可以是C/C++函数或者汇编语言函数，对于汇编函数，使用_main的函数名。由于此时的硬件、软件中断还没有被使能，所以在用户主函数的初始化中需要注意，可以使能单独的中断屏蔽位，但是不能调用类似HWI_enable的接口来使能全局中断；</p></li>
<li><p>调用BIOS_start启动DSP/BIOS：BIOS_start在用户main函数退出后被调用，它负责使能使用的各个模块并调用MOD_startup启动每个模块。包括CLK_startup、PIP_startup、SWI_startup、HWI_startup等。当TSK管理模块在配置中被使用时，TSK_startup被执行，并且BIOS_start将不会结束返回；</p></li>
<li><p>执行idle循环：有两种方式进入idle循环。当TSK管理模块使能时，任务调度器运行的TSK_idle任务调用IDL_loop在其它任务空闲时进入idle循环；当TSK模块未被使用时，BIOS_start调用将返回，并执行IDL_loop进入永久的idle循环，此时硬件和软件中断可以抢占idle循环得到执行。由于idle循环中管理和主机的通信，因此主机和目标机之间的数据交互可以进行了</p></li>
</ol>
<p>从上述的启动过程我们可以分析一下为什么在操作系统中main函数不需要使用while(1)死循环：因为在DSP/BIOS中，main函数只是被操作系统调用用来进行初始化的，执行完main函数后才能启动操作系统。这也给了我一个启示——如果我想在一个工程中既可以使用操作系统，又可以在某些情况下简单的禁用操作系统，只需定义一个宏开关main函数中while(1)循环就可以了！</p>
<h2 id="dspbios在dsp项目中的地位">DSP/BIOS在DSP项目中的地位</h2>
<p>下图是TI公司倡导的DSP软件架构，</p>
<div class="figure">
<img src="../images/DSP-BIOS使用入门/21.png" alt="21" /><p class="caption">21</p>
</div>
<p>由图可知，</p>
<ol style="list-style-type: decimal">
<li><p>由CSL负责DSP芯片级外设的驱动，这部分是软件开发人员最底层的代码，DSP/BIOS负责底层的调度，方便应用层的管理，还有Driver模块，我认为是其它的非DSP芯片级的驱动，如USB/PCI等外设接口</p></li>
<li><p>中间层主要是算法相关的东西，TI提供了一个DSP算法的标准，只要按该标准编写的算法能很容易的实现不同DSP之间的移植</p></li>
<li><p>再上层就是应用程序了</p></li>
</ol>
<p>这就是TI的DSP高端大气上档次的三层软件架构！</p>
<h2 id="参考资料">参考资料</h2>
<ol style="list-style-type: decimal">
<li>SPRU430S: TMS320C6000 DSP/BIOS 5.x Application Programming Interface (API) Reference Guide</li>
<li>SPRU423F: TMS320 DSP BIOS User Guide</li>
<li>SPRU616A: DSP-BIOS Driver Developer's Guide</li>
<li>刘鑫茂：DSP/BIOS讲座</li>
</ol>
<div class="ds-thread" data-thread-key="DSP-BIOS使用入门" data-title="DSP-BIOS使用入门" data-url="xiahouzuoxin.github.io/notes/html/DSP-BIOS使用入门.html"></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"5","bdPos":"right","bdTop":"300"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"xiahouzuoxin"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->

<div id="footer">
    <p class="footer_subline">联系邮箱: xiahouzuoxin@163.com</p>
    <p class="footer_subline">声明: 本站所有文章如非特别说明均为原创，转载请注明出处！
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1253219218'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1253219218%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
    </p>
</div>

<!-- 回到顶部 -->
<script>
lastScrollY=0;
function heartBeat(){
var diffY;
if (document.documentElement && document.documentElement.scrollTop)
    diffY = document.documentElement.scrollTop;
else if (document.body)
    diffY = document.body.scrollTop
else
    {/*Netscape stuff*/}
percent=.1*(diffY-lastScrollY);
if(percent>0)percent=Math.ceil(percent);
else percent=Math.floor(percent);
document.getElementById("full").style.top=parseInt(document.getElementById("full").style.top)+percent+"px";
lastScrollY=lastScrollY+percent;
}
suspendcode="<div id=\"full\" style='right:1px;POSITION:absolute;TOP:600px;z-index:100'><a onclick='window.scrollTo(0,0);'><img src='../images/top.png'></a><br></div>"
document.write(suspendcode);
window.setInterval("heartBeat()",1);
</script>
</body>
</html>
